"""Common type declarations for ai-scalper-god."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, Iterable, List, Literal, Optional

Direction = Literal["long", "short"]


def _utcnow() -> datetime:
    """Return a timezone-aware UTC ``datetime``."""

    return datetime.now(tz=timezone.utc)


class Regime(str, Enum):
    """Enumerated market regimes recognised by the system."""

    TREND = "trend"
    RANGE = "range"
    VOLATILE_TREND = "volatile_trend"
    QUIET = "quiet"


@dataclass(slots=True)
class FeatureWindow:
    """Represents a computed feature for a given timestamp and timeframe."""

    name: str
    timeframe: str
    timestamp: datetime
    value: Any


@dataclass(slots=True)
class SignalCandidate:
    """Signal candidate produced by multi-timeframe gates before final scoring.

    Attributes:
        symbol: Instrument identifier.
        direction: Trade direction (``"long"`` or ``"short"``).
        confidence: Normalised confidence between 0 and 1.
        ttl: Time-to-live in **seconds**.
        invalidation: Price level that invalidates the setup.
        strategy: Identifier of the originating strategy/gate.
        metadata: Auxiliary information for downstream modules.
        created_at: Creation timestamp in UTC.
    """

    symbol: str
    direction: Direction
    confidence: float
    ttl: int
    invalidation: float
    strategy: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=_utcnow)

    def expires_at(self) -> datetime:
        """Return the expiry timestamp for the candidate.

        A non-positive ``ttl`` indicates that the candidate does not expire. This is
        mainly used in tests and dry-runs. Production components should always
        provide a strictly positive TTL to avoid stale signals lingering in the
        system.
        """

        if self.ttl <= 0:
            return datetime.max.replace(tzinfo=timezone.utc)
        return self.created_at + timedelta(seconds=self.ttl)

    def is_valid(self, current_time: datetime | None = None) -> bool:
        """Return whether the candidate remains tradable."""

        if self.ttl <= 0:
            return True
        moment = current_time or _utcnow()
        return moment <= self.expires_at()


@dataclass(slots=True)
class OrderRequest:
    """Represents an order to be sent to the execution layer."""

    symbol: str
    direction: Direction
    size: float
    order_type: str
    price: Optional[float]
    stop_loss: Optional[float]
    take_profit: Optional[float]
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class StrategyPackState:
    """State of a compiled strategy pack produced by the DSL compiler."""

    name: str
    enabled: bool
    regimes: Iterable[Regime]
    parameters: Dict[str, Any] = field(default_factory=dict)


@dataclass(slots=True)
class RiskLimits:
    """Risk limit snapshot for quick checks during routing."""

    daily_drawdown_pct: float
    max_losing_streak: int
    correlation_limit: float
    spread_cap_bps: float
    latency_cap_ms: float


@dataclass(slots=True)
class ResearchIdea:
    """Represents a new strategy idea generated by research agents."""

    name: str
    description: str
    proposed_by: str
    created_at: datetime
    dsl_snippet: str
    tags: List[str] = field(default_factory=list)
    score: Optional[float] = None


__all__ = [
    "Direction",
    "Regime",
    "FeatureWindow",
    "SignalCandidate",
    "OrderRequest",
    "StrategyPackState",
    "RiskLimits",
    "ResearchIdea",
]
